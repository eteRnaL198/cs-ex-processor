情報科学演習
プロセッサ演習
第1,2週
学籍番号: 2021061
氏名: 永木 郁也
実施年月日: 2022 年 6 月 27 日,7 月 4 日
提出年月日: 2022 年 7 月 10 日
1 第1週の課題
下記の動作確認は、全て遅延分岐を設定せずに実行した。
1.1 分岐命令の動作確認
1.1.1 条件に応じた分岐の動作確認
ソースコード 1 の実行結果は、$t0=11, $t1=10 となった。処理の流れとしてはまず 2,3 行目で$t0,$t1
にそれぞれ 10,9 が代入される。4 行目で$t0,$t1 の値を比較し、等しければ TRUE へ分岐する。この場
合は等しくないため 6 行目によって ELSE へ分岐する。ELSE では$t1 がインクリメントされて 10 と
なり、処理が終了する。
ソースコード 1: branch1.asm
1 .text
2 addi $t0, $zero, 10 # X
3 # addi $t1, $zero, 9 # Y
4 addi $t1, $zero, 10 # Y
5 beq $t0, $t1, TRUE # 等しければTRUE へ
6 # bne $t0, $t1, TRUE # 等しければTRUE へ
7
8 j ELSE # ELSE へ
9
10 TRUE:
11 addi $t0, $t0, 1 # X++
12 j EXIT # EXIT へ
13
14 ELSE:
15 addi $t1, $t1, 1 # Y++
16 EXIT:
17 li $v0, 10 # プログラムの終了
18 syscall
ソースコード 1 における 2,3 行目の値を変更したソースコード 2 の実行結果は$t0=12,$t1=11 となっ
た。4 行目で$t0,$t1 の値を比較し、両者ともに 10 で等しいため TRUE へ分岐した。TRUE では$t0 が
インクリメントされて 11 となり、処理が終了する。
ソースコード 2: branch1.asm 変更後
1 .text
2 addi $t0, $zero, 10 # X
3 addi $t1, $zero, 10 # Y
4 beq $t0, $t1, TRUE # 等しければTRUE へ
5
6 j ELSE # ELSE へ
7
1/??
8 TRUE:
9 addi $t0, $t0, 1 # X++
10 j EXIT # EXIT へ
11 (後略)
ソースコード 1 における 4 行目の条件を変更したソースコード 3 の実行結果は$t0=11,$t1=10 となっ
た。4 行目で$t0,$t1 の値を比較し、等しくないため TRUE へ分岐した。TRUE では$t0 がインクリメ
ントされて 11 となり、処理が終了する。
ソースコード 3: branch1.asm 変更後
1 .text
2 addi $t0, $zero, 10 # X
3 addi $t1, $zero, 9 # Y
4 bne $t0, $t1, TRUE # 等しければTRUE へ
5
6
7 j ELSE # ELSE へ
8
9 TRUE:
10 addi $t0, $t0, 1 # X++
11 j EXIT # EXIT へ
12 (後略)
1.2 ロード/ストア命令の動作確認
1.2.1 メモリのロード/ストアの動作確認
ソースコード 4 の実行結果は$t0=10,$t1=9,$t2=10,$t3=9, また表 1 のようになった。
ソースコード 4: ldst1.asm
1 .text
2 lui $s0, 0x00001001 # データの先頭番地A
3 addi $t2, $zero, 10 # X
4 addi $t3, $zero, 9 # Y
5 sw $t2, 0($s0) # X の値を(A+0)番地にストア
6 sw $t3, 4($s0) # Y の値を(A+4)番地にストア
7 lw $t0, 0($s0) # (A+0)番地の値をロード
8 lw $t1, 4($s0) # (A+4)番地の値をロード
9 # sw $t0, 8($s0) # (A+8)番地にストア
10 # sw $t1, 12($s0) # (A+12)番地にストア
11 sw $t1, 8($s0) # (A+8)番地にストア
12 sw $t0, 12($s0) # (A+12)番地にストア
13
14
15 li $v0, 10 # プログラムの終了
2/??
16 syscall
表 1: ldst1 の結果
アドレス 値
0x10010000 10
0x10010004 9
0x10010008 10
0x1001000c 9
処理の流れとして、まず 3,4 行目で$t2,$t3 にそれぞれ 10,9 が代入される。5,6 行目で$s0 番地,$s0+4
番地に$t2,$t3 の値つまり 10,9 をそれぞれストアする。次に$t0,$t1 にそれぞれ$s0,$s0+4 番地の値つま
り 10,9 をそれぞれロードする。最後に$s0+8,$s0+12 番地に$t0,$t1 の値つまり 10,9 をそれぞれストア
する。
ソースコード 4 の 9,10 行目におけるストアする値$t0 と$t1 を入れ替えたソースコード??の実行結
果は$t0=10,$t1=9,$t2=10,$t3=9, また表 2 のようになった。コードを変更する前との違いは、表 2 の
下 2 つの値の順番が逆になっていることである。8(%s0) と 12($s0) にストアする値を入れ替えたため
このような結果になった。
表 2: ldst1 の結果 (2)
アドレス 値
0x10010000 10
0x10010004 9
0x10010008 9
0x1001000c 10
1.2.2 データのスワップ処理の動作確認
ソースコード 5 の処理は次のようになる。まず 0x00001001 番地から順に 14,12,11,15 がストアされ
る。$s1 にはデータの先頭番地、$s2 には先頭から 2 つ目のデータの番地が代入される。15 行目で$s2 と
$s0 が比較され、ここでは$s2 は$s0 より大きいため 16 行目では EXIT へ分岐しない。18 行目から 21 行
目によってデータの入れ替えが行われ、データは先頭から順に 14,12,15,11 となる。22 行目によって$s2
にデータの先頭から 1 つ目の番地が代入され、LOOP へ分岐する。再び$s0 と$s2 が比較され、EXIT
へ分岐せずにデータの入れ替えが行われる。この入れ替えによってデータは先頭から順に 14,15,12,11
となる。次の 22 行目によって$s2 データの先頭番地が代入される。$s0 と$s2 を比較すると 2 つとも同
じ値であり$s2¡$s0 を満たさず$t0 に 0 が代入される。このループでの入れ替えによってデータは先頭
から 15,14,12,11 となる。次の 22 行目によって$s2 データの先頭より 1 つ前の番地が代入される。$s0
と$s2 の比較で$s2¡$s0 を満たし$t0 に 1 が代入される。16 行目で$t0 は 0 でないため EXIT へ分岐して
処理が終了する。
3/??
ソースコード 5: swap1.asm
1 .text
2 lui $s0, 0x00001001 # データの先頭番地A
3 addi $t0, $zero, 14
4 sw $t0, 0($s0) # (A+0)番地
5 addi $t0, $zero, 12
6 sw $t0, 4($s0) # (A+4)番地
7 addi $t0, $zero, 11
8 sw $t0, 8($s0) # (A+8)番地
9 addi $t0, $zero, 15
10 sw $t0, 12($s0) # (A+12)番地
11
12 add $s1, $zero, $s0 # データの先頭番地A
13 addi $s2, $s1, 8 # k = A+8
14 LOOP:
15 slt $t0, $s2, $s0 # k < A なら 1
16 bne $t0, $zero, EXIT # k < A なら EXIT へ
17
18 lw $t0, 0($s2) # $t0 に(k+0)番地の値をロード
19 lw $t1, 4($s2) # $t1 に(k+4)番地の値をロード
20 sw $t0, 4($s2) # $t0 の値を(k+4)番地にストア
21 sw $t1, 0($s2) # $t1 の値を(k+0)番地にストア
22 addi $s2, $s2, -4 # 1つ前のデータへ
23 j LOOP # LOOP へ
24
25 EXIT:
26 li $v0, 10 # プログラムの終了
27 syscall
1.3 バブルソートのプログラム作成
1.3.1 少数 (4 件) のデータでの動作確認
作成したバブルソートのプログラムをソースコード 6 に示す。また、実行した後のデータを表??に
示す。実行後のデータは降順になっており、正しくソートされていることが確認できた。
行われる処理について以下で説明する。まず 11,12 行目で$t2,$t3 を 0 に初期化する。$t2,$t3 は繰り
返しを行うためのカウンタであり、$t3 が 0 から始めて 3 になったら$t2 に 1 を加算し$t3 は 0 に戻る。
このように$t2 をインクリメントしてデータの総数である 4 になったらループから抜け出して処理を終
了させる。ループを抜け出すまでに$t3*$t4=3*4=12 回繰り返されることになる。
15,16 行目で$t0,$t1 にデータの先頭と次の値をロードする。18 行目で$t0¡$t1 であるか比較し、成り
立てば Bubble1 へ分岐、そうでなければ 21,22 行目によって$t0¿$t1 つまり 2 つのデータ間で降順にな
るよう入れ替える。Bubble1 ではまず$s1 に次のデータの番地を代入し、$t3 をインクリメントする。
26 行目で$t3 が 3 であるか比較し、成り立てば Bubble2 へ分岐、そうでなければ Bubble へ分岐する。
4/??
つまり$t3 が 3 になるまで Bubble をループする。Bubble2 では$t3 を 0 へ戻し、$t2 をインクリメント、
さらに$s1 の値をデータの先頭番地に戻す。34 行目で$t2 が 4 であるか比較し、そうでなければ Bubble
へ分岐する。4 であれば処理が終了する。
ソースコード 6: バブルソート データ数 4
1 (前略)
2 Sort0:
3 #####################################
4 #↓以下に並び替えのプログラム記述
5 # ここだけに追加記入すること
6
7 add $s1, $zero, $s0 # データの先頭番地を$s1 に保存
8 # t0 arr[j+1]
9 # t1 arr[j+1]
10 addi $t2, $zero, 0 # i
11 addi $t3, $zero, 0 # j
12 # t4 tmp
13
14 Bubble: lw $t0, 0($s1)
15 lw $t1, 4($s1)
16 # cmp
17 slt $t4, $t0, $t1
18 beq $t4, $zero, Bubble1
19 # swap
20 sw $t0, 4($s1)
21 sw $t1, 0($s1)
22 Bubble1: addi $s1, $s1, 4
23 addi $t3, $t3, 1
24 addi $t4, $zero, 3
25 beq $t3, $t4, Bubble2 # if(t3 == 3) goto Bubble2
26 j Bubble
27
28 Bubble2: addi $t3, $zero, 0
29 addi $t2, $t2, 1
30 add $s1, $zero, $s0 # s1 = s0
31
32 addi $t4, $zero, 4
33 bne $t2, $t4, Bubble
34
35 li $v0, 1
36 syscall
37
38 #↑ここまで
39 #####################################
40 (後略)
5/??
表 3: バブルソート前のデータ
アドレス 値
0x10010000 4
0x10010004 1
0x10010008 2
0x1001000c 3
表 4: バブルソート後のデータ
アドレス 値
0x10010000 4
0x10010004 3
0x10010008 2
0x1001000c 1
1.3.2 100 件のデータでの動作確認
100 件のデータをバブルソートするためには、ソースコード 6 のループする条件を変えれば良い。変
更したソースコードを??に示す。ループする条件は 3 行目と 11 行目であり、データ数に合わせてそれ
ぞれ 99,100 に書き換えた。また、21 行目と 22 行目を入れ替えてテストコードを処理させた。なぜなら
変更する前は遅延分岐される事を考えて分岐するコードの 1 行下に次の要素へ移動するよう記述され
ていたが、今回は遅延分岐をオフにして実行したため、分岐する前に次の要素へ移動させる必要があ
るからである。そして実行結果は$t5=100 となり、正しくソートされたことが確認できた。なお、ソー
トが誤っていれば$t5=300 となる。
ソースコード 7: バブルソート データ数 100
1 (前略)
2 Bubble1: addi $s1, $s1, 4
3 addi $t3, $t3, 1
4 addi $t4, $zero, 99
5 beq $t3, $t4, Bubble2 # if(t3 e == 99) goto Bubble2
6 j Bubble
7
8 Bubble2: addi $t3, $zero, 0
9 addi $t2, $t2, 1
10 add $s1, $zero, $s0 # s1 = s0
11
12 addi $t4, $zero, 100
13 bne $t2, $t4, Bubble
14 (中略)
15 TAtest:
16 addi $t0, $t0, -1 # 配列の中身が降順ソートされたか判定
17 beq $t0, $zero, TAt # 最後まであっていたらブザーは鳴らない
6/??
18 nop
19 lw $t1, 0($s1) # 配列のロード
20 nop
21 addi $s1, $s1, 4 # 次の配列の要素へ移動
22 beq $t0, $t1 TAtest # 真の値と配列を比較
23 addi $t5, $zero, 300 # 違っている場合は高いブザー
24 sw $t5, 12($s3)
25 j TAstop
26 nop
27 (後略)
1.4 挿入ソートのプログラム作成
1.4.1 100 件のデータでの動作確認
作成した挿入ソートのプログラムをソースコード??に示す。実行結果は$t5=100 となり、正しくソー
トされたことが確認できた。
処理の流れは、まず 7,8 行目で初期化を行う。$s1 にはデータの先頭番地から 1 つ先を、$t0 は 0 を
代入する。
14 行目で$s2 に$s1 より 1 つ後ろ、ここでは先頭のデータの番地を代入する。15 行目で$t1 に$s1 番
地、ここでは先頭から 1 つ先のデータの値をロードし、この値よりもインデックスが小さい側のデー
タが降順となるためにはどこに配置すればよいのかを後続の処理で判定する。17,18 行目では分岐の判
定をしており、$s2+4 が$s0 になる時、つまり$s2=$s0-4 となりデータが格納されている番地から外れ
た場合 I2 へ分岐する。20～22 行目ではデータの入れ替えを行うかの判定を行う。今配置を考えている
$s1 の値が$s2 より大きければ 2 つの値を入れ替えて、データが降順になるようにする。25 行目で$s2
の値を小さくしており、$s2 がデータの先頭になるか、$s1 の値が$s2 より小さくなるまで入れ替えを繰
り返す。I2 ではまず$s1 を、降順にするため適切であると判定された番地へストアする。そして$s1,$t0
をインクリメントする。$t0 が 99 になるまでこれを繰り返すことによって選択ソートができる。
ソースコード 8: 挿入ソート データ数 4
1 (前略)
2 Sort0:
3 #####################################
4 #↓以下に並び替えのプログラム記述
5 # ここだけに追加記入すること
6
7 addi $s1, $s0, 4 # データの先頭番地から 1つ先を$s1 に保存
8 addi $t0, $zero, 0
9 # t0 i
10 # t1 s[i] current
11 # t8 tmp
12 # t9 tmp
13
7/??
14 Insertion: addi $s2, $s1, -4
15 lw $t1, 0($s1) # tmp = s[i] current
16
17 I1: addi $t9, $s2, 4
18 beq $t9, $s0, I2 # s2 == s0 - 4 goto I2
19
20 lw $t8, 0($s2)
21 slt $t9, $t1, $t8 # s2 <= s1 goto I2
22 bne $t9, $zero, I2
23 lw $t9, 0($s2)
24 sw $t9, 4($s2) # s[j(<i)] = s[j]
25 addi $s2, $s2, -4
26 j I1
27 I2: sw $t1, 4($s2) # s[j+1] = tmp
28 addi $s1, $s1, 4
29 addi $t0, $t0, 1
30 addi $t9, $zero, 99
31 bne $t0, $t9, Insertion # t0 < 99 goto Insertion
32 li $v0, 1 # プログラムの終了
33 syscall
34
35 #↑ここまで
36 #####################################
37 (中略)
38 addi $s1, $s1, 4 # 次の配列の要素へ移動
39 addi $t5, $zero, 300 # 違っている場合は高いブザー
40 (後略)
2 第2週の課題
2.1 パイプライン処理の動作確認
2.2 データハザードとフォワーディングの動作確認
2.2.1 ハザード検出なし・フォワーディングなし
実行結果をソースコード 9 に示す。11 行目の alu a と alu b が xxxxxxxx となっている。これは addi
$s1, $zero, 5 と addi $s2, $zero, 3 によって$s1,$s2 にデータが代入される処理が完了する前に add $t1,
$s1, $s2 で$s1 と$s2 を読み込んでいるからである。12 行目では alu a に 5 が読み込めるようになり、
13 行目では alu a に 5,alu b に 3 が読み込めるようになる。また、16 行目と 17 行目にも alu a や alu b
が xxxxxxxx となっている。これは 14 行目の lw $s3, 0($s0) が完了する前に$s3 を読んでいるからで
ある。18 行目では$s3 が読み込めるようになり、3+3=6 が計算されている。本来は 3+3=6, 6+6=12,
12+12=24 が計算され、最後は 24 になるはずだが、最初の 2 回は$s3 が読み込めていないため、和算
が行われたのは 1 度のみで 3+3=6 より 6 が代入されている。
8/??
ソースコード 9: 制御ハザードの動作 (ハザード検出なし・フォワーディングなし)
1 VCD info: dumpfile mips.vcd opened for output.
2 cycle | pc | inst d f ra rb rd | alu_a alu_b | alu_q ram_din | dst reg_din
3 xxxxx | xxxxxxxx | xxxxxxxx 0 0 x x x | xxxxxxxx xxxxxxxx | 00000000 xxxxxxxx |
x xxxxxxxx
4 xxxxx | 00400000 | 00000000 0 0 0 0 0 | xxxxxxxx xxxxxxxx | 00000000 xxxxxxxx
| x xxxxxxxx
5 00000 | 00400000 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000 xxxxxxxx
| 0 00000000
6 00000 | 00400000 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 0 00000000
7 00001 | 00400004 | 3c101001 0 0 0 0 16 | 00000000 00000000 | 00000000
00000000 | 0 00000000
8 00002 | 00400008 | 20110005 0 0 0 0 17 | 00000000 00001001 | 00000000
00000000 | 0 00000000
9 00003 | 0040000c | 20120003 0 0 0 0 18 | 00000000 00000005 | 10010000
00000000 | 0 00000000
10 00004 | 00400010 | 02324020 0 0 17 18 8 | 00000000 00000003 | 00000005
00000000 | 16 10010000
11 00005 | 00400014 | 02324820 0 0 17 18 9 | xxxxxxxx xxxxxxxx | 00000003
00000000 | 17 00000005
12 00006 | 00400018 | 02325020 0 0 17 18 10 | 00000005 xxxxxxxx | xxxxxxxx
xxxxxxxx | 18 00000003
13 00007 | 0040001c | ae120000 0 0 16 18 0 | 00000005 00000003 | xxxxxxxx
xxxxxxxx | 8 xxxxxxxx
14 00008 | 00400020 | 8e130000 0 0 16 0 19 | 10010000 00000000 | 00000008
00000003 | 9 xxxxxxxx
15 00009 | 00400024 | 02739820 0 0 19 19 19 | 10010000 00000000 | 10010000
00000003 | 10 00000008
16 0000a | 00400028 | 02739820 0 0 19 19 19 | xxxxxxxx xxxxxxxx | 10010000
00000000 | 0 10010000
17 0000b | 0040002c | 02739820 0 0 19 19 19 | xxxxxxxx xxxxxxxx | xxxxxxxx
xxxxxxxx | 19 00000003
18 0000c | 00400030 | 2402000a 0 0 0 0 2 | 00000003 00000003 | xxxxxxxx xxxxxxxx
| 19 xxxxxxxx
19 0000d | 00400034 | 0000000c 0 0 0 0 0 | 00000000 0000000a | 00000006
00000003 | 19 xxxxxxxx
20 0000e | 00400038 | 00000000 0 0 0 0 0 | 00000000 00000000 | 0000000a
00000000 | 19 00000006
21 0000f | 0040003c | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 2 0000000a
22 00010 | 00400040 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 0 00000000
23 cycle = 16
9/??
2.2.2 ハザード検出のみあり
実行結果をソースコード 10 に示す。11 行目と 12 行目では$s1,$s2 にデータが代入される前に実行さ
れており、ストールが発生している。13 行目からはデータを正しく読み取れるようになり、5+3 が計
算されている。また 18,19 行目でも同様にデータを読み取れるようになるまでストールが起こり、20
行目でデータを読み取り 3+3=6 が計算されている。同様に 21,22,24,25 行目でもストールが発生し、
23,26行目でデータを読み取り和算が行われている。ハザード検出を有効にした場合は3+3=6, 6+6=12,
12+12=24 のように計算され、28 行目の reg din は 0x18 つまり 24 となっており、正しく処理が実行さ
れている。31 行目の cycle はソースコード 9 のときよりも 8 だけ多くなっており、これはストールが複
数回発生したためである。
ソースコード 10: 制御ハザードの動作 (ハザード検出あり・フォワーディングなし)
1 VCD info: dumpfile mips.vcd opened for output.
2 cycle | pc | inst d f ra rb rd | alu_a alu_b | alu_q ram_din | dst reg_din
3 xxxxx | xxxxxxxx | xxxxxxxx x 0 x x x | xxxxxxxx xxxxxxxx | 00000000 xxxxxxxx |
x xxxxxxxx
4 xxxxx | 00400000 | 00000000 0 0 0 0 0 | xxxxxxxx xxxxxxxx | 00000000 xxxxxxxx
| x xxxxxxxx
5 00000 | 00400000 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000 xxxxxxxx
| 0 00000000
6 00000 | 00400000 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 0 00000000
7 00001 | 00400004 | 3c101001 0 0 0 0 16 | 00000000 00000000 | 00000000
00000000 | 0 00000000
8 00002 | 00400008 | 20110005 0 0 0 0 17 | 00000000 00001001 | 00000000
00000000 | 0 00000000
9 00003 | 0040000c | 20120003 0 0 0 0 18 | 00000000 00000005 | 10010000
00000000 | 0 00000000
10 00004 | 00400010 | 02324020 1 0 17 18 8 | 00000000 00000003 | 00000005
00000000 | 16 10010000
11 00005 | 00400010 | 02324020 1 0 17 18 8 | 00000000 00000000 | 00000003
00000000 | 17 00000005
12 00006 | 00400010 | 02324020 0 0 17 18 8 | 00000000 00000000 | 00000000
00000000 | 18 00000003
13 00007 | 00400014 | 02324820 0 0 17 18 9 | 00000005 00000003 | 00000000
00000000 | 0 00000000
14 00008 | 00400018 | 02325020 0 0 17 18 10 | 00000005 00000003 | 00000008
00000003 | 0 00000000
15 00009 | 0040001c | ae120000 0 0 16 18 0 | 00000005 00000003 | 00000008
00000003 | 8 00000008
16 0000a | 00400020 | 8e130000 0 0 16 0 19 | 10010000 00000000 | 00000008
00000003 | 9 00000008
17 0000b | 00400024 | 02739820 1 0 19 19 19 | 10010000 00000000 | 10010000
00000003 | 10 00000008
18 0000c | 00400024 | 02739820 1 0 19 19 19 | 00000000 00000000 | 10010000
00000000 | 0 10010000
10/??
19 0000d | 00400024 | 02739820 0 0 19 19 19 | 00000000 00000000 | 00000000
00000000 | 19 00000003
20 0000e | 00400028 | 02739820 1 0 19 19 19 | 00000003 00000003 | 00000000
00000000 | 0 00000000
21 0000f | 00400028 | 02739820 1 0 19 19 19 | 00000000 00000000 | 00000006
00000003 | 0 00000000
22 00010 | 00400028 | 02739820 0 0 19 19 19 | 00000000 00000000 | 00000000
00000000 | 19 00000006
23 00011 | 0040002c | 02739820 1 0 19 19 19 | 00000006 00000006 | 00000000
00000000 | 0 00000000
24 00012 | 0040002c | 02739820 1 0 19 19 19 | 00000000 00000000 | 0000000c
00000006 | 0 00000000
25 00013 | 0040002c | 02739820 0 0 19 19 19 | 00000000 00000000 | 00000000
00000000 | 19 0000000c
26 00014 | 00400030 | 2402000a 0 0 0 0 2 | 0000000c 0000000c | 00000000
00000000 | 0 00000000
27 00015 | 00400034 | 0000000c 0 0 0 0 0 | 00000000 0000000a | 00000018 0000000
c | 0 00000000
28 00016 | 00400038 | 00000000 0 0 0 0 0 | 00000000 00000000 | 0000000a
00000000 | 19 00000018
29 00017 | 0040003c | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 2 0000000a
30 00018 | 00400040 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 0 00000000
31 cycle = 24
2.2.3 両方あり
実行結果をソースコード??に示す。11 行目では、ソースコードフォワーディングが無い時はストー
ルが発生していたが、今回はフォワーディングによってストールが発生せずにデータを読み込めてい
る。16 行目ではストールが一度発生している。これは 14 行目で lw $s3, 0($s0) を実行しており、フォ
ワーディングを有効にしてもロードの結果を直後に使用するには間に合わないためである。28 行目の
reg din は 0x18 つまり 24 となっており、3+3=6, 6+6=12, 12+12=24 が正しく計算されていることが
わかる。31 行目の cycle はソースコード 9 の 16 よりも 1 だけ多くなっており、これはストールが一度
だけ発生したためである。
ソースコード 11: 制御ハザードの動作 (ハザード検出あり・フォワーディングあり)
1 VCD info: dumpfile mips.vcd opened for output.
2 cycle | pc | inst d f ra rb rd | alu_a alu_b | alu_q ram_din | dst reg_din
3 xxxxx | xxxxxxxx | xxxxxxxx x x x x x | xxxxxxxx xxxxxxxx | 00000000 xxxxxxxx |
x xxxxxxxx
4 xxxxx | 00400000 | 00000000 0 0 0 0 0 | xxxxxxxx xxxxxxxx | 00000000 xxxxxxxx
| x xxxxxxxx
5 00000 | 00400000 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000 xxxxxxxx
| 0 00000000
11/??
6 00000 | 00400000 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 0 00000000
7 00001 | 00400004 | 3c101001 0 0 0 0 16 | 00000000 00000000 | 00000000
00000000 | 0 00000000
8 00002 | 00400008 | 20110005 0 0 0 0 17 | 00000000 00001001 | 00000000
00000000 | 0 00000000
9 00003 | 0040000c | 20120003 0 0 0 0 18 | 00000000 00000005 | 10010000
00000000 | 0 00000000
10 00004 | 00400010 | 02324020 0 1 17 18 8 | 00000000 00000003 | 00000005
00000000 | 16 10010000
11 00005 | 00400014 | 02324820 0 1 17 18 9 | 00000005 00000003 | 00000003
00000000 | 17 00000005
12 00006 | 00400018 | 02325020 0 0 17 18 10 | 00000005 00000003 | 00000008
00000003 | 18 00000003
13 00007 | 0040001c | ae120000 0 0 16 18 0 | 00000005 00000003 | 00000008
00000003 | 8 00000008
14 00008 | 00400020 | 8e130000 0 0 16 0 19 | 10010000 00000000 | 00000008
00000003 | 9 00000008
15 00009 | 00400024 | 02739820 1 0 19 19 19 | 10010000 00000000 | 10010000
00000003 | 10 00000008
16 0000a | 00400024 | 02739820 0 1 19 19 19 | 00000000 00000000 | 10010000
00000000 | 0 10010000
17 0000b | 00400028 | 02739820 0 1 19 19 19 | 00000003 00000003 | 00000000
00000000 | 19 00000003
18 0000c | 0040002c | 02739820 0 1 19 19 19 | 00000006 00000006 | 00000006
00000003 | 0 00000000
19 0000d | 00400030 | 2402000a 0 0 0 0 2 | 0000000c 0000000c | 0000000c 00000006
| 19 00000006
20 0000e | 00400034 | 0000000c 0 0 0 0 0 | 00000000 0000000a | 00000018 0000000c
| 19 0000000c
21 0000f | 00400038 | 00000000 0 0 0 0 0 | 00000000 00000000 | 0000000a
00000000 | 19 00000018
22 00010 | 0040003c | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 2 0000000a
23 00011 | 00400040 | 00000000 0 0 0 0 0 | 00000000 00000000 | 00000000
00000000 | 0 00000000
24 cycle = 17
2.3 制御ハザードの動作確認
2.3.1 遅延分岐なし
2.3.2 遅延分岐あり
2.4 ソートプログラムの修正
12/??
